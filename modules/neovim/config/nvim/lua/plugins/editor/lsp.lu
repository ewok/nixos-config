local map = require("lib").map
local conf = require("conf")

-- https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md
return {
    {
        "kosayoda/nvim-lightbulb",
        event = { "BufReadPost", "BufNewFile" },
        config = function()
            local nvim_lightbulb = require("nvim-lightbulb")
            nvim_lightbulb.setup({
                ignore = {},
                sign = { enabled = true, priority = 15 },
                float = { enabled = false, text = "ðŸ’¡", win_opts = {} },
                virtual_text = { enabled = false, text = "ðŸ’¡", hl_mode = "replace" },
                status_text = { enabled = false, text = "ðŸ’¡", text_unavailable = "" },
            })

            vim.fn.sign_define("LightBulbSign", {
                text = "ðŸ’¡",
                texthl = "DiagnosticSignWarn",
                linehl = "",
                numhl = "",
            })

            vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
                pattern = "*",
                callback = function()
                    nvim_lightbulb.update_lightbulb()
                end,
            })
        end,
    },
    {
        "VonHeikemen/lsp-zero.nvim",
        branch = "v3.x",
        event = { "BufReadPre", "BufNewFile" },
        dependencies = {
            { "neovim/nvim-lspconfig" },
            {
                "ray-x/lsp_signature.nvim",
                opts = {},
                config = function(_, opts)
                    require("lsp_signature").setup(opts)
                end,
            },
            {
                "SmiteshP/nvim-navic",
                config = function()
                    local navic = require("nvim-navic")
                    navic.setup({
                        highlight = true,
                    })
                end,
            },
        },
        init = function()
            map("n", "<leader>li", "<cmd>LspInfo<CR>", { noremap = true }, "Info")
            map("n", "<leader>ls", "<cmd>LspStart<CR>", { noremap = true }, "Start")
            map("n", "<leader>lS", "<cmd>LspStop<CR>", { noremap = true }, "Stop")
            map("n", "<leader>lr", "<cmd>LspRestart<CR>", { noremap = true }, "Restart")
            map("n", "<leader>ll", "<cmd>LspLog<CR>", { noremap = true }, "Log")
        end,
        config = function()
            local icons = conf.icons.diagnostic
            local lsp_zero = require("lsp-zero")
            local sig = require("lsp_signature")
            local navic = require("nvim-navic")

            lsp_zero.on_attach(function(client, bufnr)
                sig.on_attach({
                    bind = true,
                    handler_opts = {
                        border = "rounded",
                    },
                }, bufnr)

                if client.server_capabilities.documentSymbolProvider then
                    navic.attach(client, bufnr)
                end

                map(
                    "n",
                    "<leader>cdw",
                    "<cmd>lua vim.diagnostic.setqflist()<cr>",
                    { buffer = bufnr },
                    "[lsp] Code workspace diagnostics"
                )
                map(
                    "n",
                    "<leader>cdd",
                    "<cmd>lua vim.diagnostic.setloclist()<cr>",
                    { buffer = bufnr },
                    "[lsp] Code document diagnostics"
                )
                map("n", "K", "<cmd>lua vim.lsp.buf.hover()<cr>", { buffer = bufnr }, "[lsp] Hover documentation")
                map(
                    "n",
                    "gd",
                    "<cmd>vsplit | lua vim.lsp.buf.definition()<cr>",
                    { buffer = bufnr },
                    "[lsp] Go to definition"
                )
                map(
                    "n",
                    "gD",
                    "<cmd>vsplit | lua vim.lsp.buf.declaration()<cr>",
                    { buffer = bufnr },
                    "[lsp] Go to declaration"
                )
                map(
                    "n",
                    "gi",
                    "<cmd>vsplit | lua vim.lsp.buf.implementation()<cr>",
                    { buffer = bufnr },
                    "[lsp] Go to implementation"
                )
                map(
                    "n",
                    "go",
                    "<cmd>lua vim.lsp.buf.type_definition()<cr>",
                    { buffer = bufnr },
                    "[lsp] Go to type definition"
                )
                map("n", "gr", "<cmd>lua vim.lsp.buf.references()<cr>", { buffer = bufnr }, "[lsp] Go to reference")

                map("n", "<leader>cn", "<cmd>lua vim.lsp.buf.rename()<cr>", { buffer = bufnr }, "[lsp] Rename symbol")

                map(
                    "n",
                    "<leader>ca",
                    "<cmd>lua vim.lsp.buf.code_action()<cr>",
                    { buffer = bufnr },
                    "[lsp] Execute code action"
                )
                if vim.lsp.buf.range_code_action then
                    map(
                        "x",
                        "<leader>ca",
                        "<cmd>lua vim.lsp.buf.range_code_action()<cr>",
                        { buffer = bufnr },
                        "[lsp] Execute code action"
                    )
                else
                    map(
                        "x",
                        "<leader>ca",
                        "<cmd>lua vim.lsp.buf.code_action()<cr>",
                        { buffer = bufnr },
                        "[lsp] Execute code action"
                    )
                end

                map("n", "gl", "<cmd>lua vim.diagnostic.open_float()<cr>", { buffer = bufnr }, "[lsp] Show diagnostic")
                map("n", "[d", "<cmd>lua vim.diagnostic.goto_prev()<cr>", { buffer = bufnr }, "[lsp] Prev diagnostic")
                map("n", "]d", "<cmd>lua vim.diagnostic.goto_next()<cr>", { buffer = bufnr }, "[lsp] Next diagnostic")
            end)

            lsp_zero.set_sign_icons({
                error = icons.Error,
                warn = icons.Warn,
                hint = icons.Hint,
                info = icons.Info,
            })
            local lspconfig = require("lspconfig")
            lspconfig.nil_ls.setup({})

            for lsp_name, settings in pairs(require("lib").lsps) do
                lspconfig[lsp_name].setup({
                    handlers = {
                        lsp_zero.default_setup,
                    },
                    settings = settings,
                })
            end
        end,
    },
    {
        "nvimtools/none-ls.nvim",
        config = function()
            require("null-ls").setup()
            function NULL_is_ls_formatting_enabled(bufnr)
                local file_type = vim.api.nvim_buf_get_option(bufnr, "filetype")
                local generators = require("null-ls.generators").get_available(
                    file_type,
                    require("null-ls.methods").internal.FORMATTING
                )
                return #generators > 0
            end
        end,
        keys = {
            {
                "<leader>cf",
                function()
                    local bufnr = vim.api.nvim_get_current_buf()
                    vim.lsp.buf.format({
                        filter = function(client)
                            local null_supported = NULL_is_ls_formatting_enabled(bufnr)

                            if client.name == "null-ls" and null_supported then
                                vim.notify("Formatting with: " .. client.name, nil, { title = "FMT" })
                                return true
                            elseif null_supported then
                                return false
                            else
                                if client.supports_method("textDocument/formatting") then
                                    vim.notify("Formatting with: " .. client.name, nil, { title = "FMT" })
                                    return true
                                end
                                return false
                            end
                        end,
                        bufnr = bufnr,
                    })
                end,
                mode = { "n", "v" },
                desc = "[null] Format file or range",
            },
        },
    },
    {
        "zeioth/garbage-day.nvim",
        event = { "BufReadPre", "BufNewFile" },
        opts = {},
    },
}
